# Graphs

 	



### Depth First Search



Algorithm

- DFS function (input is adjecency list)
  - Create a `seen` stack.
  - go through each key of adjecency list 
  - compare key with its existance in the `seen` stack
  - if not in the `seen` list then create a `return stack` for the explore function and call explore 
  - otherwise print previously returned `explored stack`  
- Explore function (node, adjecency list, seen stack, explored stack)
  - add given node on seen stack and explored stack
  - collect list of neighbours from its adjecency list 
  - go through neighbours' list compare each element against seen stack 
  - if not seen then recurse with explore function 



```ruby
#!/usr/bin/env ruby
require 'pp'
adjList = {
   1 => [ 2, 5 ],
   2 => [ 1, 4 ],
   4 => [ 5, 2, 7, 8 ],
   5 => [ 1, 4 ],
   7 => [ 4, 8 ], 
   8 => [ 7, 4 ]
}



def dfs(list)
    
    seen = []
    list.each do |k,v|
        next if seen.include?(k)
        stack = []
        explore(k,list,seen,stack)
        pp stack
    end

end


def explore(n,list,seen,stack)
    seen.append(n) 
    stack.append(n)
    
    neigh = list[n] 
    neigh.each do |nn|
        explore(nn,list,seen,stack) unless seen.include?(nn)
    end
    
    return stack
end

dfs(adjList)
```

 

